## Необходимые модули
Для работы модуля необходимы следующие библиотеки:  
Стандартные: `time, enum, math, threading`.  
Дополнительные:  
- RPi.GPIO - для работы с GPIO Raspberry Pi  
Устанавливается либо через pip3: `sudo pip3 install RPi.GPIO`, либо через apt: `sudo apt install python3-rpi.gpio`
- smbus - для работы с шиной i2c  
Устанавливается из репозитория: `sudo apt install python3-smbus`

## Описание модуля
Для работы с различными элементами платы создаются определенные объекты классов, представленных в модуле.  
Чтобы получить к ним доступ, модуль необходимо импортировать:  
`import RPiPWM`

## Переферийные устройства
Для работы с внешними устройствами необходимо создать объект соответствующего класса.  
***ВНИМАНИЕ:*** **По опыту использования, у разных сервоприводов может быть разный угол 
при одних и тех же значениях ШИМ. Рекомендуется брать сервоприводы у одного поставщика.**  
Конструкторы классов принимают 2 параметра:  
- `channel` - номер канала  
- `extended` - флаг, работать ли в расширенном диапазоне (0.5 - 2.5 мс вместо 1 - 2 мс по умолчанию)
- `freq` - частота работы микросхемы (устанавливается из списка `RPiPWM.PwmFreq`, например `RPiPWM.PwmFreq.H50`), может
принимать значения `H50`, `H125`, `H250` соответственно для 50 Гц, 125 Гц или 250 Гц  
  
***ВНИМАНИЕ:*** **Расширенный диапазон использовать с осторожностью, на крайних значениях возможно он будет повреждать
механизм сервопривода.**  

***ВНИМАНИЕ:*** **Частота работы микросхемы определяет частоту ВСЕХ 16 КАНАЛОВ. Частота работы микросхемы задается при 
создании первого устройства.**  
  
Методы классов также для всех одинаковы:  
- `setValue` - установить значение (входной параметр зависит от класса)  
- `setMcs` - установить значение длительности импульса ШИМ (**Устанавливается в мкс. Минимальное значение 0, 
максимальное - зависит от частоты работы микросхемы. Реальная длительность может отличаться на 50-70 мкс.**)  
***ВНИМАНИЕ:*** **Установка длительности импульса больше значений установленных для сервопривода производителем
(обычно 500-2500 мкс максимум) МОЖЕТ ПРИВЕСТИ К ПОВРЕЖДЕНИЮ ПРИВОДА**
- `getValue` - возвращает последнее установленное значение (либо через функцию setValue, либо через функцию setMcs, 
зависит от того, что было вызвано последним)  
- `getMcs` - возвращает последнее установленное значение длительности импульса ШИМ, которое читается напрямую с
микросхемы (**точность - до cотен мкс, возвращает int**)

Возможные варианты (в скобках даны значения для функции `setValue`):  
- `Servo90` - сервопривод с углом поворота 90 градусов (0 - 90 градусов)  
- `Servo120` - сервопривод с углом поворота 180 градусов (0 - 120 градусов)  
- `Servo180` - сервопривод с углом поворота 180 градусов (0 - 180 градусов)  
- `Servo270` - сервопривод с углом поворота 270 градусов (0 - 270 градусов)  
- `ForwardMotor` - драйвер мотора, работающий только в одном направлении (0 - 100 % скорости)  
- `ReverseMotor` - драйвер мотора с возможностью реверса (-100 - 100 % скорости)  
- `Switch` - просто переключение между высоким и низким уровнем сигнала (True/False - вкл или выкл)
  
При попытке задать два устройства на один канал возникает ошибка.  
При попытке задать `ForwardMotor` или `ReverseMotor` на каналы 0 - 11 высвечивается предупреждение.

## АЦП
Для работы с АЦП необходимо создать объект класса `RPiPWM.Battery()`. У данной микросхемы нет возможности задать
адрес вручную, поэтому изменение адреса в классе не предусмотрено.  
Констркутор класса принимает на вход
два параметра:  
- `vRef` - опорное напряжение в вольтах, относительно которого производится измерение (по умолчанию 3.3 В)  
- `gain` - коэффициент делителя напряжения (по умолчанию 7.66, т.е. во сколько раз напряжение, измеряемое АЦП
меньше напряжения питания)

##### Методы класса:  

- `start` - наследуется от threading.Thread. Запускает измерения в отдельном потоке (треде)
- `stop` - останавливает поток АЦП, нужен для корректного завершения программы
- `getVoltageInstant` - возвращает моментальное значение напряжения с АЦП
- `getVoltageFiltered` - возвращает отфильтрованное значение напряжения с АЦП
- `calibrate` - **экспериментальная функция**, на вход функции подается значение фактического напряжения
на клеммах платы, в результате функция изменяет значение коэффициента делителя напряжения в соответствии
входным напряжением  

## I2C Дисплей
Предусмотрено подключение OLED дисплеев на базе микросхемы **SSD1306**. Для работы с дисплеем необходимо создать 
объект одного из трех классов `RPiPWM.SSD1306_128_64()`, `RPiPWM.SSD1306_128_32()` или 
`RPiPWM.SSD1306_96_16()`, в зависимости от размеров дисплея. Возможность задания адреса дисплея при создании объекта
не предусмотрена, поэтому можно подключить только один указанный дисплей. Входных параметров у конструктора нет.

##### Методы класса:
- `begin` - включает дисплей
- `getSize` - возвращает ширину и высоту дисплея (в формате width, height)
- `image` - сохраняет заданное изображение в буффер. Входной параметр - image - картинка, созданная с помощью
 модуля PIL. Режим картинки должен быть mode = 1 и по размеру она должна совпадать с дисплеем.
 (подробнее см. [example.py](https://github.com/victorvorobev/RPiPWM/blob/master/example.py))
- `display` - выводит буффер на экран
- `clear` - очищает буффер
- `setBrightness` - задает яркость дисплея в диапазоне от 0 до 255  

## Кнопка и светодиод
Для работы с кнопкой и светодиодом, запаянными на плате, используется класс `RPiPWM.Gpio`. 
При создании объекта класса дополнительные парамтеры не задаются. Кнопка связана с GPIO 20, светодиод - с GPIO 21.

##### Методы класса:
- `buttonAddEvent` - связывает функцию с нажатием на кнопку. 
В качестве параметра передается непосредственно функция.
- `ledSet` - включает или выключает светодиод. Входной параметр - значение для светодиода (True или False)
- `ledToggle` - переключает состояние светодиода
- `cleanUp` - освобождает GPIO после завершения работы
